# КОНСТРУКТОР И ДЕСТРУКТОР
## КОНСТРУКТОР

В прошлом уроке мы создали класс `Wi-Fi Router`, в котором создали сеттер с условием — "изменить пароль, но только если старый введен верно", чтобы защитить наш любимый и дорогой интернет от маленьких вредителей = )
Но а вдруг брат каким-то образом разузнал старый пароль, сменил на новый и дальше пользуется вай-файчиком как хочет?
```cpp
WiFiRouter router;
router.setPassword("123, ЭтоЖеЯ"); // Установили пароль...
router.setPassword("ЭтоЖеЯ, 1234567890"); // Брат все-таки поменял! Всё сломалось.
std::cout << router.getPassword(); // Брат увидел пароль и рассказал всем.
```
Ты понимаешь: __пароль должен задаваться только один раз — при создании роутера.__

Переобъявляем класс:
```cpp
class WiFiRouter {
private:
    std::string password;

public:
    // Конструктор, где пароль задаётся ТОЛЬКО при создании
    WiFiRouter(const std::string& initialPassword) {
        password = initialPassword;
    }

    // Геттер УДАЛЁН! Пароль нельзя просто так прочитать.
    // Сеттер УДАЛЁН! Пароль нельзя менять.

    // Единственный безопасный способ "дать доступ"
    bool checkPassword(const std::string& input) const {
        return input == password;
    }
};
```
Брат негодует, но зато интернет в безопасности.
Теперь он может только __пробовать__ пароль (через checkPassword), но __не менять__ его.



*__Конструктор - функция, запускаемая в момент создания объекта класса.__*

```cpp
class Point {

private:

    double x = 0.0;
    double y = 0.0;

public:

    Point(int _x, int _y) { // Конструктор

        x = _x;
        y = _y;

    }

    void output() {

        cout << “(” << x << “; ” << y << ”)” << endl;

    }

};
```
- Тип возвращаемого значения не указывается
- Имена параметров и полей класса теперь не могут быть одинаковыми

__Создание объекта:__

`Point p(0, 0); //Точка с координатами x=0 и y=0`
`Point p; // ошибка компиляции =(`

Почему?

По умолчанию, если в классе не определен ни один конструктор, компилятор автоматически добавляет пустой конструктор без параметров.
Однако, если в классе объявлен хотя бы один пользовательский конструктор (с параметрами или без), то неявный конструктор по умолчанию больше не создается, а значит создать объект без параметров уже не получится.

Что тогда делать?
```cpp
class Point {

private:

    double x = 0.0;
    double y = 0.0;

public:

    Point() {} // создаем конструктор по умолчанию

    Point(int _x, int _y) {

        x = _x;
        y = _y;

    }

    void output() {

        cout << “(” << x << “; ” << y << ”)” << endl;

    }

};
```
`Point p; // ошибки больше нет!`

В C++ класс может содержать __неограниченное количество конструкторов__, но каждый из них должен __иметь уникальную сигнатуру__ (разный набор параметров по типам и количеству).
Это называется __перегрузкой конструкторов.__
```cpp
class Rectangle{

private:

    int width, height;

public:

    Rectangle(int _width, int _height) {

        width = _width;

        height = _height;

    }



    Rectangle(int side) {

        width = side;

        height = side;

    }

};
```
Когда запускается конструктор, сначала поля класса создаются либо с мусором, либо со значениями по умолчанию, если такие указаны, а после уже полям присваиваются новые значения. Это не так эффективно.
Гораздо лучше было бы сразу создавать поля с нужными значениями. __Список инициализации__ позволяет инициализировать значения полей ещё до запуска тела конструктора, т.е. в момент создания этих самых полей

**Как происходит инициализация полей класса?**
1. Сначала выделяется память под объект.

2. Поля инициализируются:

- Если **списка иницилизации нет** – для начала поля класса создаются либо с мусором, либо со значениями по умолчанию, если такие указаны, а после уже полям присваиваются новые значения. Это не так эффективно.

- Если **есть список инициализации** – значения задаются сразу.

3. Выполняется тело конструктора (если есть присваивания, они происходят уже после инициализации).

**Список инициализации** позволяет инициализировать значения полей ещё до запуска тела конструктора, т.е. в момент создания этих самых полей.

Пример:
```cpp
class Point {

    double x = 0.0, y = 0.0;

public:

    Point(int x, int y): x(x), y(y) {}

    void output() {

        cout << “(” << x << “; ” << y << ”)” << endl;

    }

};
```
- Имена параметров и полей класса теперь могут быть одинаковыми


Можно одновременно использовать и список инициализации, и тело конструктора.
**Как это работает?**

1. **Сначала** выполняется инициализация полей из **списка инициализации** (в порядке их объявления в классе, а не в списке).
2. **Затем** выполняется код в **теле конструктора**.

## ДЕСТРУКТОР

Представь, что твой класс — это твоя комната. Зима. Ты приходишь вечером после школы и идешь к себе в комнату доделывать какой-нибудь проект в тишине и без яркого раздражающего света. Но вдруг к тебе заходит мама поинтересоваться как у тебя дела. Что она тебе говорит? "Дорогой, ну что ты как вампир, включи свет, зрение испортишь!". По совету мамы (или чисто чтобы она больше не приставала) ты теперь включаешь свет каждый раз, когда заходишь в комнату вечером. Ну так вот:

- **Конструктор** — это когда ты заходишь в комнату, включаешь свет, достаешь ноутбук.

Утром ты приготовил поесть и идешь в школу. Перед уходом ты должен выключить плиту, закрыть окна, выключить свет и т.п.

- **Деструктор** — это когда ты обязан выключить свет, закрыть окно и убрать мусор за собой перед уходом в школу.

_**Деструктор - специальный тип метода класса, который выполняется при удалении объекта класса, выполняя освобождение использованных объектом ресурсов.**_

Когда объект автоматически выходит из области видимости или же динамический объект удаляется с помощью `delete`, запускается деструктор. Как и конструктор, имя деструктора совпадает с именем класса, но в начале добавляется тильда `~`:
```cpp
~имя класса() {

}
```
```cpp
class Room {
private:
    bool lightOn; // Включён ли свет
    int* chaos;   // Бардак (динамическая память)
public:
    // Конструктор - "Зашли в комнату"
    Room() {
        lightOn = true;
        chaos = new int[200]; // Устроили бардак
        cout << "Зашли в комнату, включили свет, достали ноутбук" << endl;
    }

    // Деструктор - "Уходим из комнаты"
    ~Room() {
        delete[] chaos;      // Убрали за собой
        if (lightOn) {
            cout << "Выключили свет!" << endl;
        }
        cout << "Комната убрана, можно уходить" << endl;
    }
};
```
- **Освобождает ресурсы** (память, файлы, сетевые соединения).

- **Работает автоматически** (когда объект уничтожается).

- **Нельзя вызвать вручную** (это как нельзя убрать ноутбук, пока ты в нем делаешь проект).
